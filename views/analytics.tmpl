{{ define "analytics" }}
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/x-icon" href="/img/logo.ico">
  <title>SparkProxy â€¢ Request Analytics</title>
  <link rel="stylesheet" href="/css/global.css" />
  <link rel="stylesheet" href="/css/sidebar.css" />
  <link rel="stylesheet" href="/css/analytics.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jsvectormap@1.5.3/dist/css/jsvectormap.min.css" />
</head>

<body class="page-analytics">
  <div class="app">
    {{ template "sidebar" . }}
    {{ template "notifications" . }}

    <main class="content" role="main" aria-labelledby="page-title">
      <header class="page-header">
        <div class="left">
          <h1 id="page-title">Request Analytics</h1>
          <p class="subtitle">View traffic metrics and request patterns</p>
        </div>
        <div class="controls">
          <select id="domain-select">
            <option value="">All Domains</option>
          </select>
          <select id="time-range">
            <option value="24h">Last 24 hours</option>
            <option value="7d" selected>Last 7 days</option>
            <option value="30d">Last 30 days</option>
          </select>
          <button class="btn ghost" id="refresh-btn">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 12a9 9 0 1 1-2.64-6.36"/>
              <path d="M21 3v6h-6"/>
            </svg>
            Refresh
          </button>
        </div>
      </header>

      <div class="stats-row">
        <div class="stat-card">
          <div class="stat-icon blue">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M12 2L3 7v6c0 5.5 4 10 9 11 5-1 9-5.5 9-11V7l-9-5z"/>
            </svg>
          </div>
          <div class="stat-content">
            <span class="stat-value" id="total-requests">0</span>
            <span class="stat-label">Total Requests</span>
          </div>
        </div>
        <div class="stat-card">
          <div class="stat-icon red">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="10"/>
              <path d="M12 8v4M12 16h.01"/>
            </svg>
          </div>
          <div class="stat-content">
            <span class="stat-value" id="blocked-requests">0</span>
            <span class="stat-label">Blocked Requests</span>
          </div>
        </div>
        <div class="stat-card">
          <div class="stat-icon green">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
              <path d="M22 4L12 14.01l-3-3"/>
            </svg>
          </div>
          <div class="stat-content">
            <span class="stat-value" id="success-rate">0%</span>
            <span class="stat-label">Success Rate</span>
          </div>
        </div>
        <div class="stat-card">
          <div class="stat-icon orange">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/>
              <polyline points="7.5 4.21 12 6.81 16.5 4.21"/>
              <polyline points="7.5 19.79 7.5 14.6 3 12"/>
              <polyline points="21 12 16.5 14.6 16.5 19.79"/>
              <polyline points="3.27 6.96 12 12.01 20.73 6.96"/>
              <line x1="12" y1="22.08" x2="12" y2="12"/>
            </svg>
          </div>
          <div class="stat-content">
            <span class="stat-value" id="data-transfer">0 B</span>
            <span class="stat-label">Data Transfer</span>
          </div>
        </div>
      </div>

      <section class="panel" aria-label="Requests over time">
        <div class="panel-header">
          <h2>Requests Over Time</h2>
        </div>
        <canvas id="byDayChart" aria-label="Requests over time chart" role="img"></canvas>
      </section>

      <div class="grid-3">
        <section class="panel" aria-label="HTTP Methods">
          <div class="panel-header">
            <h2>HTTP Methods</h2>
          </div>
          <div id="methods-chart" class="bar-chart">
            <div class="empty-state">No data</div>
          </div>
        </section>

        <section class="panel" aria-label="Response Codes">
          <div class="panel-header">
            <h2>Response Codes</h2>
          </div>
          <div class="donut-container">
            <canvas id="responseCodesChart" class="donut-chart" width="100" height="100"></canvas>
            <div class="donut-legend" id="response-legend">
              <div class="empty-state">No data</div>
            </div>
          </div>
        </section>

        <section class="panel" aria-label="Top Paths">
          <div class="panel-header">
            <h2>Top Paths</h2>
          </div>
          <div class="table-wrap">
            <table class="table" role="grid">
              <thead>
                <tr>
                  <th scope="col">Path</th>
                  <th scope="col" class="num">Requests</th>
                </tr>
              </thead>
              <tbody id="top-paths-body">
                <tr><td colspan="2" class="empty-state">No data</td></tr>
              </tbody>
            </table>
          </div>
        </section>
      </div>

      <section class="panel grid-2" aria-label="Geographic distribution">
        <div class="panel" style="margin: 0;">
          <div class="panel-header">
            <h2>Requests by Country</h2>
          </div>
          <div class="map-wrap">
            <div id="world-map" class="world" aria-hidden="true"></div>
            <div class="tooltip" role="tooltip" hidden></div>
          </div>
        </div>

        <div class="panel" aria-labelledby="top-countries-title" style="margin: 0;">
          <div class="panel-header">
            <h2 id="top-countries-title">Top Countries</h2>
          </div>
          <div class="table-wrap">
            <table class="table" role="grid">
              <thead>
                <tr>
                  <th scope="col">Country</th>
                  <th scope="col" class="num">Requests</th>
                  <th scope="col" class="num">%</th>
                </tr>
              </thead>
              <tbody id="top-countries-body">
                <tr><td colspan="3" class="empty-state">No data</td></tr>
              </tbody>
            </table>
          </div>
        </div>
      </section>
    </main>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/jsvectormap@1.5.3/dist/js/jsvectormap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jsvectormap@1.5.3/dist/maps/world.js"></script>
  <script>
    (function () {
      if (typeof window.showToast !== 'function') {
        window.showToast = function (msg) { alert(msg); };
      }

      const domainSelect = document.getElementById('domain-select');
      const timeRangeSelect = document.getElementById('time-range');
      const refreshBtn = document.getElementById('refresh-btn');
      const canvas = document.getElementById('byDayChart');

      const totalRequestsEl = document.getElementById('total-requests');
      const blockedRequestsEl = document.getElementById('blocked-requests');
      const successRateEl = document.getElementById('success-rate');
      const dataTransferEl = document.getElementById('data-transfer');

      let worldMapInstance = null;
      let worldMapTooltip = null;
      let domains = [];

      function formatNumber(n) {
        if (typeof n !== 'number' || !isFinite(n)) return '0';
        if (n >= 1000000) return (n / 1000000).toFixed(1) + 'M';
        if (n >= 1000) return (n / 1000).toFixed(1) + 'K';
        return n.toLocaleString();
      }

      function formatBytes(bytes) {
        if (!bytes || bytes < 0) return '0 B';
        const units = ['B', 'KB', 'MB', 'GB', 'TB'];
        let unitIndex = 0;
        let size = bytes;
        while (size >= 1024 && unitIndex < units.length - 1) {
          size /= 1024;
          unitIndex++;
        }
        return size.toFixed(1) + ' ' + units[unitIndex];
      }

      function formatDateKey(d) {
        const year = d.getFullYear();
        const month = String(d.getMonth() + 1).padStart(2, '0');
        const day = String(d.getDate()).padStart(2, '0');
        return year + '-' + month + '-' + day;
      }

      function codeToFlag(code) {
        if (!code) return '';
        return code.toUpperCase().replace(/./g, function(c) { return String.fromCodePoint(127397 + c.charCodeAt(0)); });
      }

      function drawLineChart(canvas, labels, data, color) {
        if (!canvas || !labels || !data || labels.length === 0 || data.length === 0) return;

        const dpr = window.devicePixelRatio || 1;
        const displayW = canvas.parentElement ? canvas.parentElement.clientWidth : 900;
        const displayH = 280;
        canvas.style.width = '100%';
        canvas.style.height = displayH + 'px';
        canvas.width = Math.floor(displayW * dpr);
        canvas.height = Math.floor(displayH * dpr);
        const ctx = canvas.getContext('2d');
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);

        const width = displayW;
        const height = displayH;
        const padding = { t: 20, r: 24, b: 32, l: 40 };
        const areaW = width - padding.l - padding.r;
        const areaH = height - padding.t - padding.b;

        const maxVal = Math.max.apply(null, data.filter(function(v) { return isFinite(v); })) || 1;
        const step = Math.ceil(maxVal / 5) || 1;

        ctx.clearRect(0, 0, width, height);

        ctx.strokeStyle = '#1b2230';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padding.l, height - padding.b);
        ctx.lineTo(width - padding.r, height - padding.b);
        ctx.stroke();

        ctx.fillStyle = '#6b7280';
        ctx.font = '11px ui-sans-serif, system-ui';

        for (let i = 0; i < labels.length; i++) {
          const x = padding.l + (i / Math.max(labels.length - 1, 1)) * areaW;
          ctx.fillText(labels[i], x - 16, height - padding.b + 16);
        }

        for (let i = 0; i <= 5; i++) {
          const value = step * i;
          const y = padding.t + (1 - value / (step * 5)) * areaH;
          ctx.strokeStyle = i === 0 ? '#1b2230' : 'rgba(148, 163, 184, 0.15)';
          ctx.beginPath();
          ctx.moveTo(padding.l, y);
          ctx.lineTo(width - padding.r, y);
          ctx.stroke();
          ctx.fillStyle = '#6b7280';
          ctx.fillText(formatNumber(value), 4, y + 4);
        }

        ctx.lineWidth = 2;
        ctx.strokeStyle = color;
        ctx.beginPath();
        for (let i = 0; i < labels.length; i++) {
          const x = padding.l + (i / Math.max(labels.length - 1, 1)) * areaW;
          const y = padding.t + (1 - data[i] / (step * 5)) * areaH;
          if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        }
        ctx.stroke();

        const grad = ctx.createLinearGradient(0, padding.t, 0, height - padding.b);
        grad.addColorStop(0, color.replace(')', ', 0.15)').replace('rgb', 'rgba'));
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.lineTo(width - padding.r, height - padding.b);
        ctx.lineTo(padding.l, height - padding.b);
        ctx.closePath();
        ctx.fillStyle = grad;
        ctx.fill();
      }

      function drawDonutChart(canvas, data) {
        if (!canvas || !data || Object.keys(data).length === 0) return;

        const dpr = window.devicePixelRatio || 1;
        const size = 100;
        canvas.width = size * dpr;
        canvas.height = size * dpr;
        const ctx = canvas.getContext('2d');
        ctx.scale(dpr, dpr);

        const centerX = size / 2;
        const centerY = size / 2;
        const radius = size / 2 - 4;
        const innerRadius = radius * 0.6;

        const colors = {
          '2xx': '#22c55e',
          '3xx': '#3b82f6',
          '4xx': '#f59e0b',
          '5xx': '#ef4444',
          'other': '#6b7280'
        };

        const total = Object.values(data).reduce(function(a, b) { return a + b; }, 0);
        if (total === 0) return;

        const categories = { '2xx': 0, '3xx': 0, '4xx': 0, '5xx': 0, 'other': 0 };
        for (const [code, count] of Object.entries(data)) {
          const prefix = code.charAt(0);
          if (categories[prefix + 'xx'] !== undefined) {
            categories[prefix + 'xx'] += count;
          } else {
            categories['other'] += count;
          }
        }

        let currentAngle = -Math.PI / 2;
        const thickness = radius - innerRadius;

        for (const [cat, count] of Object.entries(categories)) {
          if (count === 0) continue;
          const sliceAngle = (count / total) * Math.PI * 2;
          ctx.beginPath();
          ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);
          ctx.arc(centerX, centerY, innerRadius, currentAngle + sliceAngle, currentAngle, true);
          ctx.closePath();
          ctx.fillStyle = colors[cat];
          ctx.fill();
          currentAngle += sliceAngle;
        }
      }

      function renderMethodsChart(container, methods) {
        if (!container) return;
        const entries = Object.entries(methods || {}).sort(function(a, b) { return b[1] - a[1]; }).slice(0, 6);
        if (entries.length === 0) {
          container.innerHTML = '<div class="empty-state">No data</div>';
          return;
        }

        const maxVal = entries[0][1];
        const colors = {
          'GET': '#3b82f6',
          'POST': '#22c55e',
          'PUT': '#f59e0b',
          'DELETE': '#ef4444',
          'PATCH': '#a855f7',
          'HEAD': '#6b7280',
          'OPTIONS': '#06b6d4'
        };

        let html = '';
        entries.forEach(function([method, count]) {
          const pct = maxVal > 0 ? (count / maxVal) * 100 : 0;
          const color = colors[method] || '#6b7280';
          html += '<div class="bar-item">' +
            '<span class="bar-label">' + method + '</span>' +
            '<div class="bar-track">' +
              '<div class="bar-fill" style="width: ' + pct + '%; background: ' + color + ';">' +
              '</div>' +
            '</div>' +
            '<span class="bar-value">' + formatNumber(count) + '</span>' +
          '</div>';
        });
        container.innerHTML = html;
      }

      function renderResponseLegend(container, data) {
        if (!container) return;
        const categories = { '2xx': 0, '3xx': 0, '4xx': 0, '5xx': 0 };
        let total = 0;
        for (const [code, count] of Object.entries(data || {})) {
          const prefix = code.charAt(0);
          if (categories[prefix + 'xx'] !== undefined) {
            categories[prefix + 'xx'] += count;
          }
          total += count;
        }

        const colors = { '2xx': '#22c55e', '3xx': '#3b82f6', '4xx': '#f59e0b', '5xx': '#ef4444' };
        const labels = { '2xx': '2xx', '3xx': '3xx', '4xx': '4xx', '5xx': '5xx' };

        let html = '';
        for (const [cat, count] of Object.entries(categories)) {
          if (count === 0) continue;
          const pct = total > 0 ? (count * 100 / total).toFixed(1) : 0;
          html += '<div class="legend-item">' +
            '<span class="legend-color" style="background: ' + colors[cat] + ';"></span>' +
            '<span>' + labels[cat] + ' ' + formatNumber(count) + ' (' + pct + '%)</span>' +
          '</div>';
        }
        container.innerHTML = html || '<div class="empty-state">No data</div>';
      }

      function renderTopPaths(tbody, paths) {
        if (!tbody) return;
        const entries = Object.entries(paths || {}).sort(function(a, b) { return b[1] - a[1]; }).slice(0, 10);
        if (entries.length === 0) {
          tbody.innerHTML = '<tr><td colspan="2" class="empty-state">No data</td></tr>';
          return;
        }
        let html = '';
        entries.forEach(function([path, count]) {
          html += '<tr><td>' + path + '</td><td class="num">' + formatNumber(count) + '</td></tr>';
        });
        tbody.innerHTML = html;
      }

      function renderTopCountries(tbody, countries, total) {
        if (!tbody) return;
        const entries = Object.entries(countries || {}).sort(function(a, b) { return b[1] - a[1]; }).slice(0, 10);
        if (entries.length === 0) {
          tbody.innerHTML = '<tr><td colspan="3" class="empty-state">No data</td></tr>';
          return;
        }
        let html = '';
        entries.forEach(function([code, count]) {
          const pct = total > 0 ? (count * 100 / total).toFixed(1) : 0;
          html += '<tr><td>' + codeToFlag(code) + ' ' + code + '</td><td class="num">' + formatNumber(count) + '</td><td class="num">' + pct + '%</td></tr>';
        });
        tbody.innerHTML = html;
      }

      function ensureWorldMap() {
        const mapWrap = document.querySelector('.map-wrap');
        if (!mapWrap) return null;

        if (!worldMapTooltip) {
          worldMapTooltip = mapWrap.querySelector('.tooltip');
          if (worldMapTooltip) {
            worldMapTooltip.style.position = 'absolute';
            worldMapTooltip.style.pointerEvents = 'none';
          }
        }

        const container = mapWrap.querySelector('#world-map');
        if (!container) return null;

        if (typeof window.jsVectorMap !== 'function') return null;

        if (!worldMapInstance) {
          worldMapInstance = new window.jsVectorMap({
            selector: '#world-map',
            map: 'world',
            backgroundColor: 'transparent',
            zoomButtons: false,
            regionStyle: {
              initial: {
                fill: '#323236',
                stroke: '#18181b',
                'stroke-width': 0.5
              }
            },
            series: {
              regions: [{
                attribute: 'fill',
                scale: ['#323236', '#f97316'],
                normalizeFunction: 'linear',
                values: {}
              }]
            }
          });

          const containerEl = worldMapInstance.container;
          if (containerEl && worldMapTooltip) {
            containerEl.addEventListener('mousemove', function(e) {
              const target = e && e.target;
              if (!target || !target.getAttribute) {
                worldMapTooltip.hidden = true;
                return;
              }
              const regionCode = target.getAttribute('data-code');
              if (!regionCode) {
                worldMapTooltip.hidden = true;
                return;
              }

              const code = regionCode.toUpperCase();
              const dataCounts = worldMapInstance && worldMapInstance.__dataCounts;
              const countVal = dataCounts && dataCounts[code] ? dataCounts[code] : 0;

              worldMapTooltip.hidden = false;
              worldMapTooltip.textContent = codeToFlag(code) + ' ' + code + ': ' + formatNumber(countVal);

              const rect = mapWrap.getBoundingClientRect();
              worldMapTooltip.style.left = (e.clientX - rect.left + 12) + 'px';
              worldMapTooltip.style.top = (e.clientY - rect.top + 12) + 'px';
            });

            containerEl.addEventListener('mouseleave', function() {
              if (worldMapTooltip) worldMapTooltip.hidden = true;
            });
          }
        }
        return worldMapInstance;
      }

      function updateWorldMap(counts) {
        const vm = ensureWorldMap();
        if (!vm || !counts) return;

        const valueMap = {};
        const rawCountsMap = {};
        let total = 0;

        for (const key in counts) {
          const value = Number(counts[key]) || 0;
          if (value <= 0) continue;
          const upperCode = String(key).toUpperCase();
          rawCountsMap[upperCode] = (rawCountsMap[upperCode] || 0) + value;
          total += value;
        }

        if (total === 0) {
          if (vm.series && vm.series.regions && vm.series.regions[0] && typeof vm.series.regions[0].clear === 'function') {
            vm.series.regions[0].clear();
          }
          vm.__dataCounts = {};
          return;
        }

        for (const code in rawCountsMap) {
          valueMap[code] = rawCountsMap[code] / total;
        }

        if (vm.series && vm.series.regions && vm.series.regions[0] && typeof vm.series.regions[0].setValues === 'function') {
          vm.series.regions[0].setValues(valueMap);
        }
        vm.__dataCounts = rawCountsMap;
      }

      async function loadDomains() {
        try {
          const resp = await fetch('/api/proxys');
          const data = await resp.json();
          domains = (data && data.configs) || [];
          const current = domainSelect.value;
          domainSelect.innerHTML = '<option value="">All Domains</option>';
          domains.forEach(function(d) {
            var opt = document.createElement('option');
            opt.value = d.domain;
            opt.textContent = d.domain;
            domainSelect.appendChild(opt);
          });
          domainSelect.value = current;
        } catch (e) { console.error('Failed to load domains', e); }
      }

      async function refreshAnalytics() {
        try {
          const selectedDomain = domainSelect.value;
          const timeRange = timeRangeSelect.value;

          let days = 7;
          if (timeRange === '24h') days = 1;
          else if (timeRange === '30d') days = 30;

          const [proxysResp, logsResp] = await Promise.all([
            fetch('/api/proxys').then(function(r) { return r.ok ? r.json() : null; }).catch(function() { return null; }),
            fetch('/api/logs?page=1&limit=5000').then(function(r) { return r.ok ? r.json() : { logs: [] }; }).catch(function() { return { logs: [] }; })
          ]);

          const logs = Array.isArray(logsResp.logs) ? logsResp.logs : [];
          const configs = proxysResp && Array.isArray(proxysResp.configs) ? proxysResp.configs : [];

          let filteredLogs = logs;
          if (selectedDomain) {
            filteredLogs = logs.filter(function(log) {
              return log && log.domain && log.domain.toLowerCase() === selectedDomain.toLowerCase();
            });
          }

          const totalRequests = filteredLogs.length;
          let blockedRequests = 0;
          let dataIn = 0;
          let dataOut = 0;
          const methods = {};
          const responseCodes = {};
          const paths = {};
          const countries = {};

          filteredLogs.forEach(function(entry) {
            if (!entry) return;
            const action = (entry.action || '').toLowerCase();
            if (action && action !== 'allow') blockedRequests++;
            dataIn += Number(entry.data_in) || 0;
            dataOut += Number(entry.data_out) || 0;

            const method = entry.method || 'UNKNOWN';
            methods[method] = (methods[method] || 0) + 1;

            const code = entry.status_code || '0';
            responseCodes[code] = (responseCodes[code] || 0) + 1;

            const path = entry.path || '/';
            paths[path] = (paths[path] || 0) + 1;

            const loc = entry.location;
            if (loc) countries[loc] = (countries[loc] || 0) + 1;
          });

          if (totalRequestsEl) totalRequestsEl.textContent = formatNumber(totalRequests);
          if (blockedRequestsEl) blockedRequestsEl.textContent = formatNumber(blockedRequests);
          if (successRateEl) {
            const success = totalRequests - blockedRequests;
            const rate = totalRequests > 0 ? (success * 100 / totalRequests) : 0;
            successRateEl.textContent = rate.toFixed(1) + '%';
          }
          if (dataTransferEl) dataTransferEl.textContent = formatBytes(dataIn + dataOut);

          if (canvas && filteredLogs.length > 0) {
            const dayKeys = [];
            const labels = [];
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            for (let i = days - 1; i >= 0; i--) {
              const d = new Date(today);
              d.setDate(d.getDate() - i);
              dayKeys.push(formatDateKey(d));
              labels.push(d.toLocaleDateString(undefined, { month: 'short', day: 'numeric' }));
            }

            const countsByDay = {};
            filteredLogs.forEach(function(entry) {
              if (!entry || !entry.timestamp) return;
              const t = String(entry.timestamp).replace(' ', 'T');
              const d = new Date(t);
              if (!isNaN(d.getTime())) {
                const key = formatDateKey(d);
                countsByDay[key] = (countsByDay[key] || 0) + 1;
              }
            });

            const data = dayKeys.map(function(k) { return countsByDay[k] || 0; });
            drawLineChart(canvas, labels, data, '#f97316');
          }

          renderMethodsChart(document.getElementById('methods-chart'), methods);
          drawDonutChart(document.getElementById('responseCodesChart'), responseCodes);
          renderResponseLegend(document.getElementById('response-legend'), responseCodes);
          renderTopPaths(document.getElementById('top-paths-body'), paths);
          renderTopCountries(document.getElementById('top-countries-body'), countries, totalRequests);
          updateWorldMap(countries);

        } catch (e) {
          console.error('Analytics error:', e);
        }
      }

      if (domainSelect) domainSelect.addEventListener('change', refreshAnalytics);
      if (timeRangeSelect) timeRangeSelect.addEventListener('change', refreshAnalytics);
      if (refreshBtn) refreshBtn.addEventListener('click', refreshAnalytics);

      loadDomains().then(refreshAnalytics);
    })();
  </script>
</body>
</html>
{{ end }}
