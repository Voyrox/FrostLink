{{ define "analytics" }}
<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/x-icon" href="/img/logo.ico">
  <title>SparkProxy â€¢ Request Analytics</title>
  <link rel="stylesheet" href="/css/global.css" />
  <link rel="stylesheet" href="/css/sidebar.css" />
  <link rel="stylesheet" href="/css/analytics.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jsvectormap@1.5.3/dist/css/jsvectormap.min.css" />
</head>

<body class="page-analytics">
  <div class="app">
    {{ template "sidebar" . }}

    <main class="content" role="main" aria-labelledby="page-title">
      <header class="page-header">
        <h1 id="page-title">Request Analytics</h1>
        <p class="subtitle">View detailed request analytics</p>
      </header>

      <section class="panel stats" aria-label="Totals">
        <div class="stat">
          <div class="stat-title">Total requests</div>
          <div class="stat-value">0</div>
        </div>
        <div class="stat">
          <div class="stat-title">Requests blocked by SparkProxy</div>
          <div class="stat-value">0 <span class="muted">(0.00%)</span></div>
        </div>
      </section>

      <section class="panel" aria-label="Requests by day">
        <div class="panel-header">
          <h2>Requests by day</h2>
        </div>
        <canvas id="byDayChart" aria-label="Requests over last 8 days" role="img"></canvas>
      </section>

      <section class="panel grid-2" aria-label="Requests by country">
        <div class="panel">
          <div class="panel-header">
            <h2>Requests by country</h2>
          </div>
          <div class="map-wrap">
            <div id="world-map" class="world" aria-hidden="true"></div>
            <div class="tooltip" role="tooltip" hidden></div>
          </div>
        </div>

        <div class="panel" aria-labelledby="top-countries-title" style="margin-top: 0 !important;">
          <div class="panel-header">
            <h2 id="top-countries-title">Top countries</h2>
          </div>
          <div class="table-wrap">
            <table class="table" role="grid">
              <thead>
                <tr>
                  <th scope="col">Country</th>
                  <th scope="col" class="num">Total</th>
                  <th scope="col" class="num">%</th>
                </tr>
              </thead>
              <tbody>
              </tbody>
            </table>
          </div>
        </div>
      </section>
    </main>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/jsvectormap@1.5.3/dist/js/jsvectormap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jsvectormap@1.5.3/dist/maps/world.js"></script>
  <script>
    (function () {
      const card = document.querySelector('.profile-card');
      if (card) {
        const img = card.querySelector('.avatar');
        const fallback = card.querySelector('.avatar-fallback');
        const nameEl = card.querySelector('.username');
        const initial = (nameEl && nameEl.textContent || '').trim().charAt(0).toUpperCase() || '?';
        if (fallback) { fallback.textContent = initial; }
        function showFallback() { if (img) { img.style.display = 'none'; } if (fallback) { fallback.style.display = 'grid'; } }
        if (!img || !img.getAttribute('src')) { showFallback(); }
        else { img.addEventListener('error', showFallback); }
      }

      const c = document.getElementById('byDayChart');
      const totalRequestsEl = document.querySelector('.panel.stats .stat:nth-child(1) .stat-value');
      const blockedRequestsEl = document.querySelector('.panel.stats .stat:nth-child(2) .stat-value');

      function formatNumber(n) {
        if (typeof n !== 'number' || !isFinite(n)) return '0';
        return n.toLocaleString();
      }

      function formatDateKey(d) {
        const year = d.getFullYear();
        const month = String(d.getMonth() + 1).padStart(2, '0');
        const day = String(d.getDate()).padStart(2, '0');
        return year + '-' + month + '-' + day;
      }

      function drawByDayChart(canvas, labels, data) {
        if (!canvas || !labels || !data || labels.length === 0 || data.length === 0) return;

        const dpr = window.devicePixelRatio || 1;
        const displayW = canvas.parentElement ? canvas.parentElement.clientWidth : 900;
        const displayH = 300;
        canvas.style.width = '100%';
        canvas.style.height = displayH + 'px';
        canvas.width = Math.floor(displayW * dpr);
        canvas.height = Math.floor(displayH * dpr);
        const ctx = canvas.getContext('2d');
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);

        const width = displayW;
        const height = displayH;
        const padding = { t: 20, r: 24, b: 28, l: 36 };
        const areaW = width - padding.l - padding.r;
        const areaH = height - padding.t - padding.b;

        let rawMax = Math.max.apply(null, data);
        if (!isFinite(rawMax)) {
          return;
        }

        const sum = data.reduce((acc, val) => acc + (Number(val) || 0), 0);
        if (sum > rawMax) {
          rawMax = sum;
        }

        if (rawMax <= 0) {
          rawMax = 1;
        }
        const maxTicks = 5;
        const tickCount = Math.min(maxTicks, Math.max(1, Math.round(rawMax)));
        const step = Math.max(1, Math.ceil(rawMax / tickCount));
        const max = step * tickCount;

        ctx.clearRect(0, 0, width, height);
        ctx.strokeStyle = '#1b2230';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padding.l, height - padding.b);
        ctx.lineTo(width - padding.r, height - padding.b);
        ctx.moveTo(padding.l, padding.t);
        ctx.lineTo(padding.l, height - padding.b);
        ctx.stroke();

        ctx.fillStyle = '#a4acb9';
        ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';

        for (let i = 0; i < labels.length; i++) {
          const x = padding.l + (i / Math.max(labels.length - 1, 1)) * areaW;
          ctx.fillText(labels[i], x - 12, height - padding.b + 18);
        }

        const yTicks = tickCount;
        for (let i = 0; i <= yTicks; i++) {
           const value = step * i;
           const y = padding.t + (1 - value / max) * areaH;
           ctx.strokeStyle = i === 0 ? '#1b2230' : 'rgba(148, 163, 184, 0.25)';
           ctx.beginPath();
           ctx.moveTo(padding.l, y);
           ctx.lineTo(width - padding.r, y);
           ctx.stroke();
           const labelText = value === 0 ? '0' : value.toFixed(0);
          ctx.fillStyle = '#a4acb9';
          ctx.fillText(labelText, 4, y + 4);
        }

        ctx.lineWidth = 2;
        ctx.strokeStyle = '#22d3ee';
        ctx.beginPath();
        for (let i = 0; i < labels.length; i++) {
          const x = padding.l + (i / Math.max(labels.length - 1, 1)) * areaW;
          const y = padding.t + (1 - data[i] / max) * areaH;
          if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        }
        ctx.stroke();
        const grad = ctx.createLinearGradient(0, padding.t, 0, height - padding.b);
        grad.addColorStop(0, 'rgba(34,211,238,.25)');
        grad.addColorStop(1, 'rgba(34,211,238,0)');
        ctx.lineTo(width - padding.r, height - padding.b);
        ctx.lineTo(padding.l, height - padding.b);
        ctx.closePath();
        ctx.fillStyle = grad;
        ctx.fill();
      }

      let worldMapInstance = null;
      let worldMapTooltip = null;

      function ensureWorldMap() {
        const mapWrap = document.querySelector('.map-wrap');
        if (!mapWrap) return null;

        if (!worldMapTooltip) {
          worldMapTooltip = mapWrap.querySelector('.tooltip');
          if (worldMapTooltip) {
            worldMapTooltip.style.position = 'absolute';
            worldMapTooltip.style.pointerEvents = 'none';
          }
        }

        const container = mapWrap.querySelector('#world-map');
        if (!container) return null;
        if (typeof window.jsVectorMap !== 'function') return null;

        if (!worldMapInstance) {
          worldMapInstance = new window.jsVectorMap({
            selector: '#world-map',
            map: 'world',
            backgroundColor: 'transparent',
            zoomButtons: false,
            regionStyle: {
              initial: {
                fill: '#323236',
                stroke: '#18181b',
                'stroke-width': 0.5
              }
            },
            series: {
              regions: [
                {
                  attribute: 'fill',
                  scale: ['#323236', '#00dd56b8'],
                  normalizeFunction: 'linear',
                  values: {}
                }
              ]
            },
            onRegionTooltipShow: function (event) {
              if (event && typeof event.preventDefault === 'function') {
                event.preventDefault();
              }
            }
          });

          const containerEl = worldMapInstance && worldMapInstance.container;
          if (containerEl && worldMapTooltip) {
            containerEl.addEventListener('mousemove', function (e) {
              const target = e && e.target;
              if (!target || !target.getAttribute) {
                worldMapTooltip.hidden = true;
                return;
              }
              const regionCode = target.getAttribute('data-code');
              if (!regionCode) {
                worldMapTooltip.hidden = true;
                return;
              }

              const code = regionCode.toUpperCase();
              const dataCounts = worldMapInstance && worldMapInstance.__dataCounts;
              const countVal = dataCounts && dataCounts[code] ? dataCounts[code] : 0;

              worldMapTooltip.hidden = false;
              worldMapTooltip.textContent = codeToFlag(code) + ' ' + code + ': ' + formatNumber(countVal);

              const rect = mapWrap.getBoundingClientRect();
              worldMapTooltip.style.left = (e.clientX - rect.left + 12) + 'px';
              worldMapTooltip.style.top = (e.clientY - rect.top + 12) + 'px';
            });

            containerEl.addEventListener('mouseleave', function () {
              if (worldMapTooltip) {
                worldMapTooltip.hidden = true;
              }
            });
          }
        }

        return worldMapInstance;
      }

      function codeToFlag(code) {
        if (!code) return 'ðŸ³ï¸';
        return code.toUpperCase().replace(/./g, c => String.fromCodePoint(127397 + c.charCodeAt(0)));
      }

      function decorateCountryFlags(panel) {
        if (!panel) return;
        const rows = panel.querySelectorAll('.table tbody tr');
        if (!rows || rows.length === 0) return;
        rows.forEach(tr => {
          const td = tr.querySelector('td');
          if (!td) return;
          if (td.querySelector('.flag')) return;
          const code = td.textContent.trim();
          const flag = codeToFlag(code);
          const span = document.createElement('span');
          span.className = 'flag';
          span.textContent = flag + ' ';
          td.prepend(span);
        });
      }

      function updateWorldMap(counts) {
        const vm = ensureWorldMap();
        if (!vm || !counts) return;

        const valueMap = {};
        const rawCountsMap = {};
        let total = 0;

        for (const key in counts) {
          if (!Object.prototype.hasOwnProperty.call(counts, key)) continue;
          const value = Number(counts[key]) || 0;
          if (value <= 0) continue;
          const upperCode = String(key).toUpperCase();
          rawCountsMap[upperCode] = (rawCountsMap[upperCode] || 0) + value;
          total += value;
        }

        if (!total) {
          if (vm.series && vm.series.regions && vm.series.regions[0] && typeof vm.series.regions[0].clear === 'function') {
            vm.series.regions[0].clear();
          }
          vm.__dataCounts = {};
          return;
        }

        for (const code in rawCountsMap) {
          if (!Object.prototype.hasOwnProperty.call(rawCountsMap, code)) continue;
          const count = rawCountsMap[code];
          const pct = count / total;
          valueMap[regionKey] = pct;
        }

        if (vm.series && vm.series.regions && vm.series.regions[0] && typeof vm.series.regions[0].setValues === 'function') {
          vm.series.regions[0].setValues(valueMap);
        } else if (typeof vm.setValues === 'function') {
          vm.setValues(valueMap);
        }
        vm.__dataCounts = rawCountsMap;
      }

      function updateTopCountries(logs) {
        const titleEl = document.getElementById('top-countries-title');
        if (!titleEl) return;
        const panel = titleEl.closest('.panel');
        if (!panel) return;
        const tbody = panel.querySelector('.table tbody');
        if (!tbody) return;

        const counts = {};
        let total = 0;
        (logs || []).forEach(entry => {
          const locRaw = (entry && entry.location) ? String(entry.location).trim() : '';
          if (!locRaw) return;
          const key = locRaw.toUpperCase();
          counts[key] = (counts[key] || 0) + 1;
          total++;
        });

        const entries = Object.entries(counts).sort((a, b) => b[1] - a[1]).slice(0, 10);
        tbody.innerHTML = '';

        entries.forEach(([countryKey, count]) => {
          const countryLabel = countryKey;
          const pct = total > 0 ? (count * 100) / total : 0;
          const tr = document.createElement('tr');
          const tdCountry = document.createElement('td');
          const tdTotal = document.createElement('td');
          const tdPct = document.createElement('td');
          tdTotal.className = 'num';
          tdPct.className = 'num';
          tdCountry.textContent = countryLabel;
          tdTotal.textContent = formatNumber(count);
          tdPct.textContent = pct.toFixed(1) + '%';
          tr.appendChild(tdCountry);
          tr.appendChild(tdTotal);
          tr.appendChild(tdPct);
          tbody.appendChild(tr);
        });

        updateWorldMap(counts);
        decorateCountryFlags(panel);
      }

      async function refreshAnalytics() {
        try {
          const [proxysResp, logsResp] = await Promise.all([
            fetch('/api/proxys').then(r => r.ok ? r.json() : null).catch(() => null),
            fetch('/api/logs').then(r => r.ok ? r.json() : { logs: [] }).catch(() => ({ logs: [] }))
          ]);
          console.log(proxysResp, logsResp);

          const configs = proxysResp && Array.isArray(proxysResp.configs) ? proxysResp.configs : [];
          const logs = Array.isArray(logsResp.logs) ? logsResp.logs : [];

          let totalRequests = logs.length;

          let blockedRequests = 0;
          logs.forEach(entry => {
            const action = (entry && entry.action ? String(entry.action) : '').toLowerCase();
            if (action && action !== 'allow') blockedRequests++;
          });

          if (totalRequestsEl) {
            totalRequestsEl.textContent = formatNumber(totalRequests);
          }
           if (blockedRequestsEl) {
             const pct = totalRequests > 0 ? (blockedRequests * 100) / totalRequests : 0;
             blockedRequestsEl.innerHTML = `${formatNumber(blockedRequests)} <span class="muted">(${pct.toFixed(2)}%)</span>`;
           }

           if (c && logs.length > 0) {
            const days = 8;
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const dayKeys = [];
            const labels = [];
            for (let i = days - 1; i >= 0; i--) {
              const d = new Date(today);
              d.setDate(d.getDate() - i);
              const key = formatDateKey(d);
              dayKeys.push(key);
              labels.push(d.toLocaleDateString(undefined, { month: 'short', day: 'numeric' }));
            }

            const countsByDay = {};
            logs.forEach(entry => {
              if (!entry || !entry.timestamp) return;
              const t = String(entry.timestamp).replace(' ', 'T');
              const d = new Date(t);
              if (isNaN(d.getTime())) return;
              const key = formatDateKey(d);
              countsByDay[key] = (countsByDay[key] || 0) + 1;
            });

            const data = dayKeys.map(k => countsByDay[k] || 0);
            drawByDayChart(c, labels, data);
            window.addEventListener('resize', () => drawByDayChart(c, labels, data));
          }

          updateTopCountries(logs);
        } catch (e) {
        }
      }

      refreshAnalytics();
    })();
  </script>
</body>

</html>
{{ end }}